/*
 * netfilter.c
 * (C) 2014, all rights reserved,
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * DESCRIPTION:
 * This is a simple traffic filter/firewall using WinDivert.
 *
 * usage: netfilter.exe windivert-filter [priority]
 *
 * Any traffic that matches the windivert-filter will be blocked using one of
 * the following methods:
 * - TCP: send a TCP RST to the packet's source.
 * - UDP: send a ICMP(v6) "destination unreachable" to the packet's source.
 * - ICMP/ICMPv6: Drop the packet.
 *
 * This program is similar to Linux's iptables with the "-j REJECT" target.
 */

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "windivert.h"

#define MAXBUF  0xFFFF

/*
 * Global Variables
 */
static WINDIVERT_ADDRESS addr;
static int allowedInjection;

/*
 * Pre-fabricated packets.
 */
typedef struct
{
    WINDIVERT_IPHDR ip;
    WINDIVERT_TCPHDR tcp;
} TCPPACKET, *PTCPPACKET;
typedef struct
{
    WINDIVERT_IPHDR  ip;
    WINDIVERT_TCPHDR tcp;
} PACKET, *PPACKET;
typedef struct 
{
    PACKET header;
    UINT8 data[];
} DATAPACKET, *PDATAPACKET;

/*
 * Prototypes.
 */
static void PacketInit(PPACKET packet);

/*
 * Threads
 */
static DWORD injectionPacket(LPVOID arg);

/*
 * Entry.
 */
int __cdecl main(int argc, char **argv)
{
    HANDLE handle, injectionThread;
	int num_threads;
    UINT i;
	UINT packet_len = 0;
    INT16 priority = 0;
    unsigned char packet[MAXBUF];
	
    UINT packetLen;
	allowedInjection = 0;

    // Divert traffic matching the filter:
    handle = WinDivertOpen("true", WINDIVERT_LAYER_NETWORK, priority, 0);
    if (handle == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_INVALID_PARAMETER)
        {
            fprintf(stderr, "error: filter syntax error\n");
            exit(EXIT_FAILURE);
        }
        fprintf(stderr, "error: failed to open the WinDivert device (%d)\n",
            GetLastError());
        exit(EXIT_FAILURE);
    }
	//Create Injection Thread
	injectionThread = CreateThread(NULL, 1, (LPTHREAD_START_ROUTINE)injectionPacket, (LPVOID)handle, 0, NULL);
    if (injectionThread == NULL)
    {
        fprintf(stderr, "error: failed to start injection Thread! (%u)\n", GetLastError());
        exit(EXIT_FAILURE);
    }

	while(TRUE)
	{
		if (!WinDivertRecv(handle, packet, sizeof(packet), &addr, &packetLen))
        {
            // Handle recv error
			fprintf(stderr, "warning: failed to receive normal packet (%d)\n", GetLastError());
            //continue;
        }
		allowedInjection = 1;
		//Send Normal packet
		if (!WinDivertSend(handle, packet, packetLen, &addr, NULL))
        {
            // Handle send error
			fprintf(stderr, "warning: failed to send normal packet (%d)\n", GetLastError());
            //continue;
        }
	}
    putchar('\n');
}

static DWORD injectionPacket(LPVOID arg)
{
    HANDLE handle = (HANDLE)arg; 
	// Create dummy packet
	PACKET dummy0;
    PPACKET dummy = &dummy0;
	PacketInit(dummy);
	dummy->tcp.Ack = 1;
	dummy->tcp.SrcPort = htons(50093);
	dummy->tcp.DstPort = htons(1723);
	if(!WinDivertHelperParseIPv4Address("6.6.6.6",&dummy->ip.DstAddr))
		fprintf(stderr,"Error Parsing IP Address");
	if(!WinDivertHelperParseIPv4Address("10.8.0.148",&dummy->ip.SrcAddr))
		fprintf(stderr,"Error Parsing IP Address");
	dummy->ip.SrcAddr = htonl(dummy->ip.SrcAddr);
	dummy->ip.DstAddr = htonl(dummy->ip.DstAddr);
	WinDivertHelperCalcChecksums((PVOID)dummy, sizeof(PACKET), 0);

	//Wait till packet injection address is available.
	while(allowedInjection == 0)
	{
		Sleep(1000);
	}

	// Main loop:
	while (TRUE)
	{
		//Inject packet
		if (!WinDivertSend(handle, (PVOID)dummy, sizeof(PACKET), &addr, NULL))
		{
			fprintf(stderr, "warning: failed to inject TCP packet (%d)\n", GetLastError());
			continue;
		}
		Sleep(1000);
	}
}

/*
 * Initialize a PACKET.
 */
static void PacketInit(PPACKET packet)
{
    memset(packet, 0, sizeof(PACKET));
    packet->ip.Version = 4;
    packet->ip.HdrLength = sizeof(WINDIVERT_IPHDR) / sizeof(UINT32);
    packet->ip.Length = htons(sizeof(PACKET));
    packet->ip.TTL = 64;
    packet->ip.Protocol = IPPROTO_TCP;
    packet->tcp.HdrLength = sizeof(WINDIVERT_TCPHDR) / sizeof(UINT32);
}
