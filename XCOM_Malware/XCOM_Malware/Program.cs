using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using PacketDotNet;
using SharpPcap;
using SharpPcap.WinPcap;

namespace XCOM_Malware
{
    class Program
    {
        private static WinPcapDevice device;

        static void Main(string[] args)
        {
            var devices = CaptureDeviceList.Instance;
            device = (WinPcapDevice)devices[0];
            device.Open();

            //Generate a random packet
            Packet bytes = CreateMalwarePacket();
            string byteString = "";
            byte[] bytesP = bytes.Bytes;
            foreach (byte b in bytesP)
            {
                byteString += Convert.ToString(b, 2);
            }

            Thread t = new Thread (new ParameterizedThreadStart(SendPacket));
            t.Start(bytes);

            while(true)
            {
                Thread.Sleep(1000);
            }
            
            t.Abort();
            Thread.Sleep(1000);
            device.Close();
            Console.WriteLine("-- Device closed.");
            Console.Write("Hit 'Enter' to exit...");
            Console.ReadLine();
        }

        private static void SendPacket(object obj)
        {
            Packet bytes = (Packet)obj;
            while (true)
            {
                try
                {
                    //Send the packet out the network device
                    device.SendPacket(bytes);
                    Console.WriteLine("-- Packet sent successfuly.");
                }
                catch (Exception e)
                {
                    Console.WriteLine("-- " + e.Message);
                }
                Thread.Sleep(2000);
            }
        }

        private static Packet CreateMalwarePacket()
        {
            //08:00:27:95:a6:a3 source mac
            //ushort tcpSourcePort = 123;
            //ushort tcpDestinationPort = 321;
            //var tcpPacket = new TcpPacket(tcpSourcePort, tcpDestinationPort);

            var ipSourceAddress = System.Net.IPAddress.Parse("10.8.0.148");
            var ipDestinationAddress = System.Net.IPAddress.Parse("6.6.6.6");
            var ipPacket = new IPv4Packet(ipSourceAddress, ipDestinationAddress);
            ipPacket.TimeToLive = 128;
            ipPacket.Checksum = ipPacket.CalculateIPChecksum();
            UdpPacket udpPacket = UdpPacket.RandomPacket();
            //udpPacket.DestinationPort = ;
            udpPacket.PayloadData = Encoding.UTF8.GetBytes("XCOM Prototype Malware: Don't be frightend, this is not real malware! Just science project");
            //udpPacket.SourcePort=50093;
            udpPacket.DestinationPort=1723;
            //udpPacket.Checksum = (ushort)udpPacket.CalculateUDPChecksum();
            ipPacket.PayloadPacket = udpPacket;
            var sourceHwAddress = "08-00-27-95-A6-A3";
            var ethernetSourceHwAddress = System.Net.NetworkInformation.PhysicalAddress.Parse(sourceHwAddress);
            var destinationHwAddress = "08-00-27-AB-3E-A6";
            var ethernetDestinationHwAddress = System.Net.NetworkInformation.PhysicalAddress.Parse(destinationHwAddress);

            // NOTE: using EthernetPacketType.None to illustrate that the Ethernet
            //       protocol type is updated based on the packet payload that is
            //       assigned to that particular Ethernet packet
            var ethernetPacket = new EthernetPacket(ethernetSourceHwAddress,
                ethernetDestinationHwAddress,
                EthernetPacketType.None);

            // Now stitch all of the packets together
            //ipPacket.PayloadPacket = tcpPacket;
            ethernetPacket.PayloadPacket = ipPacket;

            // and print out the packet to see that it looks just like we wanted it to
            Console.WriteLine(ethernetPacket.ToString());

            // to retrieve the bytes that represent this newly created EthernetPacket use the Bytes property
            //byte[] packetBytes = ethernetPacket.Bytes;
            return ethernetPacket;
        }
    }
}
